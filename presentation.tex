\documentclass{beamer}
\usetheme{Warsaw}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{pxfonts}
\usepackage{todonotes}
\usepackage{wasysym} % lambda circle symbol
\usepackage{framed}       % frames
\usepackage{amssymb}      % empty set
\usepackage{multicol}     % multi-column
\usepackage{bcprules}     % typeset inference rule

\usepackage{graphicx}
\graphicspath{ {./images/} }

\def\e{e}
\def\t{t}
\def\u{u}
\def\p{p}
\newcommand{\calculus}{$\lambda^{\RIGHTcircle}$} 
\newcommand{\quoted}[1]{\Box\;#1}
\newcommand{\lift}[1]{\texttt{lift}\;#1}
\newcommand{\qtype}[1]{\Box#1}
\newcommand{\splice}[1]{\$\;#1}
\newcommand{\fix}[1]{\texttt{fix}\;#1}
\newcommand{\app}[2]{#1\;#2}
\newcommand{\tpd}[2]{{#1}{:}{#2}}

\newcommand{\patnat}[1]{#1}
\newcommand{\patapp}[2]{#1\;#2}
\newcommand{\patref}[1]{#1}
\newcommand{\patunlift}[1]{\texttt{unlift}\;#1}
\newcommand{\patbind}[2]{\texttt{bind}[#2]\;#1}
\newcommand{\patlam}[2]{\texttt{lam}[#2]\;#1}
\newcommand{\patfix}[1]{\texttt{fix}\;#1}

\newcommand{\patmat}[4]{\patmatSP{#1}{#2}\patmatThen{#3}#4}
\newcommand{\patmatSP}[2]{#1 \sim #2\;?}
\newcommand{\patmatThen}[1]{\;#1\; \| \;}

\newcommand{\lam}[3]{\lambda#1{:}#2.#3}

\newcommand{\strip}[1]{|#1|}

\lstset{basicstyle=\ttfamily}

\title{A Mechanized Theory \\ of Quoted Code Patterns}
\author{Radosław Waśko}
\date{June 18, 2020}

\setbeamertemplate{headline}
{%
  \leavevmode%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex]{section in head/foot}%
    \hbox to .5\paperwidth{\hfil\insertsectionhead\hfil}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex]{subsection in head/foot}%
    \hbox to .5\paperwidth{\hfil\insertsubsectionhead\hfil}
  \end{beamercolorbox}%
}

\setbeamertemplate{navigation symbols}{} 


\begin{document}
  \begin{frame}
  \titlepage
\end{frame}
\begin{frame}
  \calculus \, is an extension of \textit{simply typed lambda calculus} that adds splices, quotes and quoted pattern matching. It formalizes quoted pattern matching which is being added in Scala 3. \\~\
  
  The goal of this semester project was to create mechanized proofs of soundness of that calculus, based on the paper proofs in the original paper. The project consists of 1366 lines of Coq code, of which 585 are the proofs and 455 are definitions.
\end{frame}
\begin{frame}{Overview}
  \tableofcontents
\end{frame}

\section{\calculus calculus}
\begin{frame}[fragile]{\calculus example - compared with Scala}

\begin{lstlisting}{scala}
def f(e: Expr[Int]): Expr[Int] =
  e match {
    case '{ add(0, $y) } => y
    case _ => e
  }

f(${add(0, 2)})
\end{lstlisting}

which evaluates to $\$\{2\}$ corresponds to

\begin{equation*}
f = \lam{e}{\qtype{Nat}}{\patmat{e}{\big( \patapp{\patapp{add}{\patnat{0}}}{(\patbind{y}{Nat})} \big)}{y}{e}}
\end{equation*}
\begin{equation*}
\big(\app{f \;}{\square(\app{\app{add}{0}}{2})} \big) \;\; \longrightarrow \square(2)
\end{equation*}
\end{frame}

\newcommand{\sep}{\,|\,}
\begin{frame}{\calculus syntax}

\[
\def\arraystretch{1.5}
\begin{array}{lllr}

\t & ::= & \tpd{\u}{T} \\
\u & ::= & n \sep x \sep \lam{x}{T}{\t} \sep \app{\t}{\t} \sep \fix{\t} \sep \quoted{\t} \sep \splice{\t} \sep \lift{\t} \sep \patmat{\t}{\p}{\t}{\t} \\


\p & ::= & \patnat{n} \sep \patref{x} \sep \patapp{\p}{\p} \sep \patfix{\p} \sep \patunlift{x} \sep \patbind{x}{T} \sep \patlam{x}{T} \\

T & ::= & Nat \sep T{\to}T \sep \qtype{T} \\

%\Gamma & ::= & \emptyset \sep \Gamma,x^i{:}T & typing \; environment \\
%
%i & \in & \{0, 1\} & levels
\end{array}
\]

\let\thefootnote\relax\footnotetext{Definitions from the paper \textit{A Theory of Quoted Code Patterns}}

\end{frame}

\begin{frame}{\calculus - quotes and splices}
\begin{figure}
%  \includegraphics[height=0.72\textheight]{Tbox}
%  \includegraphics[height=0.14\textheight]{Esplice}
  \includegraphics[height=0.65\textheight]{Tbox}
  \includegraphics[height=0.12\textheight]{Esplice}
    \includegraphics[height=0.09\textheight]{Elift}
\end{figure}
\end{frame}

\begin{frame}{\calculus - patterns}
\begin{figure}
  \includegraphics[height=0.12\textheight]{Tpat}
  \includegraphics[height=0.3\textheight]{Tpat-app}
  \includegraphics[height=0.2\textheight]{Tpat-my}
\end{figure}
\end{frame}

\subsection{Proving soundness}
\begin{frame}{Proving soundness}
\begin{theorem}[Progress]
  If $\emptyset \vdash^0 t \in T$, then $t$ is a value or there exists $t'$ such $t \longrightarrow^0 t'$ 
\end{theorem}

\begin{lemma}[Level Progress]
  For any given term $t$, we have:
  \begin{itemize}
    \item[(1)]  If $\Gamma^{[1]} \vdash^0 t \in T$, then $t$ is a value or  there exists $t'$ such that $t \longrightarrow^0 t'$.
    \item[(2)] If $\Gamma^{[1]} \vdash^1 t \in T$ and $(\square t) : \square T$ is not a value,  then there exists $t'$ such that $t \longrightarrow^1 t'$.
  \end{itemize}
where $\Gamma^{[1]}$ means that the environment only contains level 1 variables.
\end{lemma}
\end{frame}

\begin{frame}{Proving soundness}

\begin{theorem}[Preservation]
  If $\Gamma \vdash^i t \in T$ and $t \longrightarrow^i t'$, then $\Gamma \vdash^i t' \in T$.
\end{theorem}

\begin{lemma}[Weakening]
  If $\Gamma^{[1]} \vdash^i t \in T, x \not\in FV(\Gamma)$, then $\Gamma, x^j : T \vdash^i t \in T$.
\end{lemma}

\begin{lemma}[Substitution]
  If 
  \begin{itemize}
    \item[(1)] $\Gamma \vdash^j t_1 \in T_1$,
    \item[(2)] $\Gamma, x^j : T_1 \vdash^i t_2 \in T_2$ and
    \item[(3)] $j = 0$ or $t_2$ does not contain pattern matches,
  \end{itemize}
then $\Gamma \vdash^i t_2[x \mapsto t_1] \in T_2$.
\end{lemma}

\end{frame}


\section{De Bruijn indices}
\begin{frame}{De Bruijn indices}
To simplify the $\alpha$-equivalence relation and definition of substitution, instead of using normal names, we represent variables using De Bruijn indices

The index specifies how many binders we have to skip (in the syntax tree) to reach the one we are bound to.

\begin{equation*}
  \lambda x. \, x \; \Longrightarrow \; \lambda. \, \#0
\end{equation*}

\begin{equation*}
{\color{blue}\lambda x}. \, {\color{olive}\lambda y}. \, {\color{blue}x} \; \Longrightarrow \; {\color{blue}\lambda}. \, {\color{olive}\lambda}. \, {\color{blue}\#1}
\end{equation*}

\end{frame}

\begin{frame}{De Bruijn indices - free variables}
Indices greater than the number of binders surrounding it represent the free variables.

\begin{align*}
{\color{olive}\tpd{f}{T_1}}; \; {\color{brown}\tpd{g}{T_2}} \vdash & {\color{blue} \lambda x}. \; {\color{purple}\lambda y}. \; {\color{olive}f} \; {\color{blue}x} \; {\color{purple}y} \\
{\color{olive} T_1}; \; {\color{brown}T_2} \vdash & {\color{blue} \lambda}. \;\; {\color{purple}\lambda}. \;\; {\color{olive} \#3} \; {\color{blue}\#1} \; {\color{purple} \#0}
\end{align*}


\end{frame}

\subsection{Multiple binders in one pattern}
\begin{frame}{Beta-reduction}

$(\lambda x. \, t) \; v \quad \longrightarrow \quad t[x \mapsto v]$

becomes

$(\lambda. \, t) \; v \quad \longrightarrow \quad t[v/]$

\begin{align*}
{\color{blue}T_2}; {\color{olive}T_1} &\vdash ({\color{purple}\lambda}. \; {\color{purple}\#0} \; {\color{olive}\#1}) \; {\color{blue}\#1} \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash {\color{purple}({\color{purple}\#0} \; {\color{olive}\#1})}[{\color{blue}\#1}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash {\color{blue}\#1} \; {\color{olive}\#0}
\end{align*}
\end{frame}

\begin{frame}{Beta-reduction}

$(\lambda. \, t) \; v \quad \longrightarrow \quad t[v/]$

\begin{align*}
{\color{blue}T_2}; {\color{olive}T_1} &\vdash ({\color{purple}\lambda}. \, \lambda. \, {\color{purple}\#1}) \; {\color{blue}\#1} \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash {(}\lambda. \, {\#1}{)}[\#0 \mapsto {\color{blue}\#1}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash \lambda. \, ( {\#1})[\#1 \mapsto {\texttt{shift }\#1}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash \lambda. \, ( {\#1})[\#1 \mapsto {\#2}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash \lambda. {\color{blue}\#2}
\end{align*}
\end{frame}

\begin{frame}{Multiple binders in one pattern}
As an example: unpacking a tuple
$\texttt{unpack } (v_1, v_2) \texttt{ as } (x_1, x_2) \texttt{ in } t 
\quad \longrightarrow \quad 
t[x_1 \mapsto v_1, x_2 \mapsto v_2]$
\pause \\ \-\\
\only<4>{We need to use the \texttt{shift} operation:}
$\texttt{unpack } (v_1, v_2) \texttt{ as } (\bullet, \bullet) \texttt{ in } t \quad 
\only<2>{\xrightarrow{} \quad ?} 
\only<3>{\xrightarrow{?} \quad ((t)[e_2/])[e_1/]}
\only<4>{\longrightarrow \quad ((t)[\texttt{shift }e_2/])[e_1/]}
$ \only<3>{{\color{red} Wrong}}
\only<3>{Why?
\begin{align*}
{\color{blue}T_2}; {\color{olive}T_1} &\vdash \texttt{unpack } ({\color{blue}\#1}, {\color{olive}\#0}) \texttt{ as } ({\color{purple}\bullet}, {\color{orange}\bullet}) \texttt{ in } ({\color{purple}\#1} \; {\color{orange}\#0}) \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash {\color{purple}(}{\color{orange}({\color{purple}\#1} \; {\color{orange}\#0})}[{\color{red}\#0}/]{\color{purple})}[{\color{blue}\#1}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash {\color{purple}(}{\color{purple}\#0} \; {\color{red}\#0}{\color{purple})}[{\color{blue}\#1}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash ({\color{blue}\#1} \; {\color{blue}\#1})
\end{align*}
The {\color{red} red \#0} is now bound to the {\color{purple} purple binder}, so it could be written as $\color{purple} \#0$, but we would expect it to stay {\color{olive} \#0}.
}
\only<4>{
\begin{align*}
{\color{blue}T_2}; {\color{olive}T_1} &\vdash \texttt{unpack } ({\color{blue}\#1}, {\color{olive}\#0}) \texttt{ as } ({\color{purple}\bullet}, {\color{orange}\bullet}) \texttt{ in } ({\color{purple}\#1} \; {\color{orange}\#0}) \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash {\color{purple}(}{\color{orange}({\color{purple}\#1} \; {\color{orange}\#0})}[{(\texttt{shift }\#0)}/]{\color{purple})}[{\color{blue}\#1}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash {\color{purple}(}{\color{orange}({\color{purple}\#1} \; {\color{orange}\#0})}[{\color{olive}\#1}/]{\color{purple})}[{\color{blue}\#1}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash {\color{purple}(}{\color{purple}\#0} \; {\color{olive}\#1}{\color{purple})}[{\color{blue}\#1}/] \\
{\color{blue}T_2}; {\color{olive}T_1} &\vdash ({\color{blue}\#1} \; {\color{olive}\#0})
\end{align*}
}

\end{frame}
\section{Challenges of the mechanization}
\begin{frame}{Challenges of the mechanization}
\begin{itemize}
  \item nested pattern matching
  \item handling multiple binders
  \item mutually inductive types
  \begin{itemize}
    \item custom syntactic induction principle
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Lessons learned}
\begin{itemize}
  \item `unit' testing before starting proofs
  \pause
  \item iterative development
  \pause
  \item notations
\end{itemize}
\begin{figure}
  \includegraphics[width=0.8\textwidth]{notation}
\end{figure}

\end{frame}

\begin{frame}[fragile]{Lessons learned}
\begin{itemize}
  \item `unit' testing before starting proofs
  \item iterative development
  \item notations
  \item proof stability
  \begin{itemize}
    \item predictive names
  \end{itemize}
\end{itemize}
Prefer \texttt{assert ($Hypothesis$) as HypX.} \\ instead of just \texttt{assert ($Hypothesis$).}

\texttt{intro Ht1typ Hreduct.} instead of \texttt{intros.} if the hypothesis names are then used somewhere explicitly.

etc.


\end{frame}

\begin{frame}[fragile]{Lessons learned}
\begin{itemize}
  \item `unit' testing before starting proofs
  \item iterative development
  \item notations
  \item proof stability
  \begin{itemize}
    \item predictive names
    \item tactics using pattern matching to find right hypothesis regardless of name
  \end{itemize}
\end{itemize}
\begin{lstlisting}[mathescape=true, basicstyle=\small\ttfamily]
Ltac invV :=
  match goal with
  | H: ?G $\vdash$(L0) ?v $\in$ $\square$(?T) |- _ => inversion H; subst
  end.
\end{lstlisting}
which matches for example: \\ \texttt{H3: G $\vdash$(L0) (Quote t $:$ T1) $\in$ $\qtype{Nat}$}.

\end{frame}

\section{}
\begin{frame}

 {\Huge{Thank you :)}}
 \\~\  \\~\
 Questions?
\end{frame}
\end{document}